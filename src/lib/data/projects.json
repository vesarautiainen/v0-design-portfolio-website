[
  {
    "id": 6,
    "slug": "ubuntu-application-switcher",
    "title": "Ubuntu Application Switcher",
    "categories": ["UX Design", "Prototyping", "UI Development", "Tooling"],
    "description": "Canonical Ltd. developed Ubuntu Linux operating system for mobile devices. As part of this effort, I designed and prototyped an application switcher for Ubuntu Touch OS.",
    "thumbnail": "/project-1/composition.webp",
    "show": true,
    "featured": true,
    "featured_image": "/project-1/composition.webp",
    "year": "2015",
    "role": "Lead Interaction Designer",
    "client": "Canonical Ltd.",
    "content":[
      {
        "type": "TextSection",
        "title": "The UX Challenge",
        "text": "Application switching is one of the most often performed tasks in both mobile and desktop operating systems. Hence, it needs to be a fluid and frictionless interaction. For this project, the main requirements were: \n\n‚Ä¢ Full convergence: the same switcher would need to work on phone, tablet, and PC desktop. \n‚Ä¢ Needs to handle both windowed and non-windowed environments. \n‚Ä¢ Multiple workspace support needs to be taken into account. \n‚Ä¢ Needs to support all available input types: touch, pointer, and keyboard. \n‚Ä¢ Single code base approach (stakeholder and engineering requirement). \n‚Ä¢ The existing design relying on stacked cards needs to be taken into consideration. \n\n **The main challenges:**\n ‚Ä¢ How to create an adapting layout that transforms and covers all use cases.\n ‚Ä¢ Creating a consistent set of transitions and animations which would also be delightful to use and reinforce the user‚Äôs mental model of the system.\n ‚Ä¢ Application window size can be arbitrary and vary between the windows simultaneously on the screen.\n ‚Ä¢ Horizontal space is limited but the design needs to scale to support 0‚ÄìN applications and 0‚ÄìN workspaces."
      },
      {
        "type": "TextSection",
        "title": "The UX Approach",
        "text": "Guiding design principles that helped in the design process:\n\n ‚Ä¢ Prefer subtle and unobtrusive animations to provide quick and consistent feeling across the use cases.\n‚Ä¢ Utilize the screen real estate as well as possible and avoid overflow behind the screen edges.\n‚Ä¢ Provide easily identifiable application info (card + icon + label).\n‚Ä¢ Aim for full convergence: Same visual appearance, functionality, and interactions across form factors, devices, and input types.\n‚Ä¢ Re-use existing Ubuntu design and visual patterns.\n\nI wrote an interactive prototype to help in design. This turned out to be an invaluable approach that helped identify and solve many edge cases. The prototype also worked as partial documentation for developers."
      },
     {
        "type": "ImageGallery",
        "images": [
          {
            "src": "/project-1/switcher-sketch-1.webp",
            "alt": "Design mockup 1 showing the line staging feature in action.",
            "caption": "Design mockup 1 showing the line staging feature in action."
          },
          {
            "src": "/project-1/switcher-sketch-2.webp",
            "alt": "Design mockup 2 showing the line staging feature in action.",
            "caption": "Design mockup 2 showing the line staging feature in action."
          },
          {
            "src": "/project-1/switcher-sketch-3.webp",
            "alt": "Design mockup 3 showing the line staging feature in action.",
            "caption": ""            
          },
          {
            "src": "/project-1/switcher-sketch-4.webp",
            "alt": "Design mockup 4 showing the line staging feature in action.",
            "caption": ""            
          },
          {
            "src": "/project-1/diagram.webp",
            "alt": "Design mockup 4 showing the line staging feature in action.",
            "caption": ""            
          }
        ]
      },
      {
        "type": "EmbeddedVideo",
        "url": "https://vimeo.com/1140845194",
        "caption": "I developed and heavily used this interactive prototype during the design process to validate and refine the user experience and find parameters for layout, animations, and transitions."
      },
      {
        "type": "ImageSection",
        "title": "The final design",
        "image": "/project-1/convergence.webp",
        "alt": "An example image from the project.",
        "caption": "The same design and codebase works across phone, tablet, and desktop form factors.",
        "align": "below",
        "text": "The resulting layout is fully responsive and automatically adjusts its element sizes, margins, and visibility while maintaining a balanced look and feel. Application windows are cropped into a square shape with a suitable cropping algorithm, and the application icon and label were added to maximize application identifiability. The final design supports the following functionality: \n\n ‚Ä¢ Application switching. \n‚Ä¢ Closing applications \n‚Ä¢ Moving applications between workspaces \n‚Ä¢ Closing, reordering, and merging workspaces \n‚Ä¢ Focusing on another workspace. "
      },
      
      {
        "type": "TextSection",
        "title": "Impact",
        "text": "The converged switcher was part of the Ubuntu 10.16 release as the default Unity 8 application switcher. \nThe final implementation is an essential part of a product that was awarded: üèÜ **Orange Award for Converged Computing** at Mobile World Congress 2017."
      }
    ]
  },
  {
    "id": 4,
    "slug": "accessible-change-indicators",
    "title": "Accessible Version Control Change Indicators",
    "categories": ["UX Design", "Accessibility"],
    "description": "Designing accessible change indicators for Visual Studio to enhance code management for developers with disabilities.",
    "thumbnail": "/project-2/thumb.webp",
    "show": true,
    "featured": false,
    "featured_image": "/project-2/featured.webp",
    "year": 2021  ,
    "role": "Senior UX Designer",
    "client": "Microsoft",
    "content":[
      {
        "type": "TextSection",
        "title": "Project Overview",
        "text": "The code change indicators mark lines that have been modified, added, or deleted in the code file. The existing indicators in Visual Studio's version control system were not accessible for all users, and didn't provide change type information, being inconsistent with, for example, VS Code. I led the redesign work to ensure they were accessible and usable by all developers, regardless of their visual abilities."      
      },
      {
        "type": "ImageSection",
        "title": "UX Problem",
        "image": "/project-2/problem.webp",
        "alt": "@todo: change this alt text",
        "caption": "Emulation of how color blind users see the existing change indicators.",
        "align": "below",
        "text": "‚Ä¢ The indicators had 2 visual states **changed-not saved (yellow bar)**, and **changed-saved (green bar)** represented only by color.\n‚Ä¢ Different kinds of changes (addition, deletion, modification) don't have unique indicators.\n‚Ä¢ Imparity with Visual Studio Code.\n‚Ä¢  Not accessible for vision impaired users.\n‚Ä¢ Color contrast ratio is not sufficient for passing WCAG standards.\n‚Ä¢ Some vision impaired users can‚Äôt distinguish unsaved changes from saved changes.\n‚Ä¢ The change margin indicators don‚Äôt follow the Git status."
      },
      {
        "type": "TextSection",
        "title": "Objectives",
        "text": "‚Ä¢ Align implementation with other Microsoft products.\n‚Ä¢ Follow more industry standard style for code change indicators.\n‚Ä¢ Make sure that the new implementation is fully accessible and passes the WCAG rules and Microsoft Accessibility Standards.\n‚Ä¢ New design needs to support Line Staging feature the was being designed in parallel.\n‚Ä¢ Design for both light and dark themes."
      },
      {
        "type": "TextSection",
        "title": "Design Process",
        "text": "First we conducted user research and usability testing with developers with visual impairments to understand their needs and challenges with the existing indicators. Collaborated with accessibility experts to ensure compliance with accessibility standards and guidelines. I explored various design options, including patterns, shapes, and textures, to create indicators that were easily distinguishable by all users. I developed prototypes and shared those in the community feedback tickets and user testing. I refined the designs based on the feedback from users and experts."      
      },
      {
        "type": "TextSection",
        "title": "Design Iterations",
        "text": "We went through multiple design iterations to explore different visual representations. I tested various shapes, patterns, and color combinations to ensure that the indicators were easily distinguishable by all users. I also considered the overall aesthetics and how the new indicators would fit within the existing Visual Studio interface."
      },
      {
        "type": "ImageGallery",
        "images": [
          {
            "src": "/project-2/iterationX-textures.webp",
            "alt": "Change indicator design iteration exploring various texture patterns to represent different change types.",
            "caption": "I explored various texture patterns to represent different change types."
          },
          {
            "src": "/project-2/iterationX-signs.webp",
            "alt": "Change indicator design iteration exploring various sign and character patterns to represent different change types.",
            "caption": "Also explored various sign and character patterns."
          },
          {
            "src": "/project-2/iteration3.webp",
            "alt": "Different design concepts in iteration 3",
            "caption": "In iteration 3, users clearly preferred design concept C3.2 over the other presented options."            
          },
          {
            "src": "/project-2/iteration4-staging-information.webp",
            "alt": "Design iteration 4 was too complex.",
            "caption": "Iteration 4 was one of the most complex designs as it showed both change type and staging information. This was concluded to be too much information for users to process at once."
          }
        ]
      },
      {
        "type": "TextSection",
        "title": "Final Design and Impact",
        "text": "The final design was successfully implemented in Visual Studio 2022 version 17.3 and later. The design met all the set objectives and received positive feedback from users, particularly those with visual impairments. \n\n I submitted a patent application which was accepted and I received a patent award for the design work. \n\nSome users still preferred the old design due to familiarity, and we provided an option to switch back to the previous design if desired. Even then, the yellow and green color values were updated for better contrast and accessibility."
      },
      {
        "type": "ImageGallery",
        "images": [
          {
            "src": "/project-2/final-1.webp",
            "alt": "alt text",
            "caption": "All different change types in light and dark themes."
          },
          {
            "src": "/project-2/final-2.webp",
            "alt": "alt text",
            "caption": "State diagram. "
          },
          {
            "src": "/project-2/final-3.webp",
            "alt": "alt text",
            "caption": "Accessible color hex values ready to be tokenized. "
          }
        ]
      },
      {
      "type": "TextSection",
      "title": "Related",
      "text": "The line staging feature that I designed as well uses the new style code change indicators. Blog post by my partner program manager: [Interactive Line Staging](https://devblogs.microsoft.com/visualstudio/line-staging-interactive-staging/)"
      }
    ] 
  },
  {
    "id": 1,
    "slug": "visual-studio-copilot-extenders",
    "title": "Visual Studio Copilot Integrations",
    "categories": ["UX Design", "AI", "Prototyping"],
    "description": "Designing Copilot AI integrations across developer tools.",
    "thumbnail": "/project-3/Featured-VS-Copilot.webp",
    "show": true,
    "featured": true,
    "featured_image": "/project-3/Featured-VS-Copilot.webp",
    "year": 2025,
    "role": "Principal Designer",
    "client": "Microsoft Corporation",
    "content":[
      {
        "type": "TextSection",
        "title": "Project Overview",
        "text": "I drove the design work for GitHub Copilot integrations across toolsets throughout Visual Studio. I crafted optimized end-to-end experiences that boost developer productivity while navigating competing constraints across different feature teams, and aligning numerous stakeholders."
      },
      {
        "type": "TextSection",
        "title": "UX Challenge",
        "text": "Key challenges included:\n\n‚Ä¢ The product teams worked in silos and lacked understanding of the high-value end-to-end scenarios.\n‚Ä¢ Different experiences were fragmented, and inconsistent UI elements and language confused users and hindered productivity.\n‚Ä¢ How to introduce new powerful AI functionality on high-density UI so that it's discoverable and understandable but doesn't mess with users' muscle memory? \n\n I collaborated closely with product managers, engineers, and other Copilot designers to identify user pain points, uncover opportunities where AI could address those pain points, and break down silos between teams."
      },
      {
        "type": "ImageSection",
        "title": "Example: Editor - Rename Suggestions",
        "text": "This small piece of AI integration was added to the editor to make rename task easier. It consists of several key features:\n\n ‚Ä¢ Provide AI suggestions automatically without blocking the underlying UI.\n‚Ä¢ Allow users to opt out and turn off the suggestions permanently. \n‚Ä¢ Prevent unnecessary AI costs by cancelling LLM (Large Language Model) call if the user starts typing.\n‚Ä¢ Provide intuitive keyboard navigation for power users.\n‚Ä¢ Maintain consistency with other Copilot integrations in Visual Studio.",
        "image": "/project-3/editor-rename-suggestions.gif",
        "alt": "Image showing Editor - Rename Suggestions in responsive layout.  ",
        "caption": "Rename Suggestions prototype.",
        "align": "right"
      },
      {
        "type": "ImageSection",
        "title": "Example: Diagnostics - Visualizer",
        "text": "With the updated UI, users can write natural language queries and view relevant diagnostics data directly within the code editor. This helps developers quickly understand and address issues without needing to learn complex query languages or navigate multiple tools.",
        "image": "/project-3/diagnostics-visualizer.gif",
        "alt": "Alt text  ",
        "caption": "User can toggle on the AI prompt and refine the current expression with natural language instructions.",
        "align": "below"
      },
      {
        "type": "TextSection",
        "title": "",
        "text": "Prototypes like this are at the core of my design process. They help to validate the designs early with users and stakeholders, and also serve as a clear communication tool for engineering handoff. This one was made directly in the Figma design tool using interactive components and animation features."
      },
      {
        "type": "ImageSection",
        "title": "UX Guidelines",
        "text": "Copilot partner teams worked in silos which had resulted fragmented and inconsistent experiences. I created user experience (UX) guidelines: \n\n‚Ä¢ Established a **unified design language** for Copilot integrations across Visual Studio.\n‚Ä¢ Empowered teams to make informed **independent design decisions** without designer involvement.\n‚Ä¢ Strengthened **cross-team collaboration** and end-to-end user experience.",
        "image": "/project-3/ux-guidelines.webp",
        "alt": "An image of the table of contents for the Copilot UX Guidelines document.",
        "caption": "Table of contents for the Copilot Partner UX Guidelines.",
        "align": "right"
      },
      {
        "type": "TextSection",
        "title": "More designs...",
        "text": "While leading the design efforts for all Copilot integrations in Visual Studio, I created numerous designs across multiple teams. Here are a few additional examples:"
      },
      {
        "type": "ImageGallery",
        "images": [
          {
            "src": "/project-3/copilot-pr-description.webp",
            "alt": "Design mockup showing the flow of using Copilot PR Description.",
            "caption": "Version Control - Copilot aided PR Description flow."
          },
          {
            "src": "/project-3/local-ai-review.webp",
            "alt": "Design mockup 2 showing the new indicator interactions.",
            "caption": "Version Control - Main UI elements of Local AI Review flow."
          },
          {
            "src": "/project-3/content-exclusion.webp",
            "alt": "Design file screenshot showing high-level view to content exclusion guidelines.",
            "caption": "Content exclusion was a larger cross-team AI design task where I established clear UX guidelines and communicated those across the teams."
          },
          {
            "src": "/project-3/doc-comments.gif",
            "alt": "GIF of the doc comments Ambient AI prototype in action.",
            "caption": "Ambient AI - Doc Comments feature provides documentation on the fly based on the function code context."
          },
          {
            "src": "/project-3/generate-method.webp",
            "alt": "Generate method Ambient AI feature visualised in Visual Studio.",
            "caption": "Ambient AI - Generate Method feature helps developers quickly create new methods based on the existing code context."
          },
          {
            "src": "/project-3/performance-profiler.webp",
            "alt": "Diagnostics Performance profiler feature design mockup.",
            "caption": "A new diagnostics performance profiler launch page that provides AI-recommended tools and allows natural language queries for finding relevant performance issues."
          }
        ]
      }
    ] 
  },
  {
    "id": 3,
    "slug": "visual-studio-new-git-experience",
    "title": "Git Version Control UX Redesign",
    "categories": ["UX Design", "User Research", "Prototyping"],
    "description": "Design journey to enhance developer productivity and collaboration with a new Git version control UX for Visual Studio.",
    "thumbnail": "/project-4/thumb.png",
    "show": true,
    "featured": false,
    "featured_image": "/project-4/featured.webp",
    "year": 2020,
    "role": "Senior Designer",
    "client": "Microsoft Corporation",
    "content":[
      {
        "type": "TextSection",
        "title": "Project Overview",
        "text": "Git is the most used version control system in the world. Developers use it to manage their code changes and collaborate with other developers. Visual Studio IDE (Integrated Development Environment) had a Git experience that was outdated and not user-friendly. I led the redesign effort to make it more intuitive, efficient, and accessible for all developers."
      },
      
      {
        "type": "ImageSection",
        "title": "UX Problem",
        "image": "/project-4/teamexplorer.webp",
        "alt": "Version control interface with multiple issues highlighted.",
        "caption": "Multiple problems identified in the existing version control interface.",
        "align": "right",
        "text": "Version control features were hosted in Team Explorer tool window UI. While many users old were used to that UI, it suffered from discoverability and usability issues that became obvious in our customer interviews and user surveys. Some of the key issues were:\n\n ‚Ä¢ Poor discoverability of the window and its key features especially for new Git users.\n ‚Ä¢ Lack of modern Git workflow support.\n ‚Ä¢ The UI didn't follow the UX guidelines. Instead it introduced some anti-patterns.\n ‚Ä¢ Inconsistent terminology and iconography compared to other Git tools.\n ‚Ä¢ Deep information hierarchy introduced complex navigation system and broken mental model."
      },
      {
        "type": "TextSection",
        "title": "User Research and Key Findings",
        "text": "With my assistance my partner program managers and researchers (kudos to Taysser Gherfal, Pratik Nadagouda, and Karl Melder) conducted user interviews and usability tests to gather insights into developers' pain points with the existing version control UX. We wanted to understand how developers use Git in their daily workflows, what challenges they face, and what features they value the most."
      },
      {
        "type": "ImageGallery",
        "images": [
          {
            "src": "/project-4/card-sorting.webp",
            "alt": "Card sorting exercise with user feedback notes.",
            "caption": "Card sorting exercise to understand user mental models and organize version control features logically."  
          },
          {
            "src": "/project-4/affinity.webp",
            "alt": "Affinity diagramming with user research data.",
            "caption": "Sensemaking with affinity diagramming to identify key themes."
          },
          {
            "src": "/project-4/table.webp",
            "alt": "Table with organized user research insights.",
            "caption": "Version control commands and features organized in 2 dimensions based on the gathered data."
          }
        ]
      },
      {
        "type": "TextSection",
        "text": "In our research it became clear that users needed just a very focused sub-set of features during their coding time (inner-loop) that should be easy to access and use without breaking their coding flow. On the other hand, there was a need for a more comprehensive and detailed version control UI that could support more complex workflows and use cases (outer-loop)."
      },
      {
        "type": "TextSection",
        "title": "Guiding Design Principles",
        "text": "The scope of version control feature was very large. I drove the effort to define clear design principles to guide the redesign process and to frame the decision making process with stakeholders:\n\n **1. Build trust and confidence**\nThrough predictable, transparent, and reliable interactions. \n\n **2. Make system status always visible** \nUsers should never guess what‚Äôs happening or what changed. \n\n **3. Protect focus and flow** \nMinimize context switching and support fast, lightweight inner-loop actions. \n\n **4. Enable effortless discovery in context**\nSurface features naturally as part of the workflow.\n\n**5. Stay true to Git**\nPrefer native Git terminology and its default behavior."
      },
      {
        "type": "ImageSection",
        "title": "Git Changes Tool Window (inner-loop experience)",
        "image": "/project-4/on-the-side.webp",
        "alt": "A design mockup of the Git Changes tool window UI.",
        "caption": "Git Changes \"on the side\" tool window UI.",
        "align": "below",
        "text": "This the final design of the coding time experience. This tool window UI sits always readily \"on the side\" of the main coding UI providing quick access to the most common version control tasks without breaking the coding flow. Its main purpose is to support fast commit and sync operations during the inner-loop coding time."
      },
      {
        "type": "TextSection",
        "text": "One of the biggest design challenges was to decide what to add and what to left out from this UI to keep it simple and focused. As a designer, I was very protective and opinionated about keeping this UI minimalistic and only with the most essential features."
      },
      {
        "type": "ImageSection",
        "title": "Git Repository window (outer-loop experience)",
        "image": "/project-4/git-repository.webp",
        "alt": "A design mockup of the Git Repository window UI.",
        "caption": "Git Repository window provides the \"focused experience\"",
        "align": "below",
        "text": "Git Repository window provides a comprehensive view to the repository status and allows users to perform all version control tasks in one place. User can open this window when they need to perform more complex workflows that require more context and information."
      },
      {
        "type": "TextSection",
        "text": "With this UI the main challenge comes from the high-density information layout. One single window needs to support a wide variety of use cases and workflows while keeping the UI understandable and usable. The multi-panel layout with collapse, expand, resize, and detach capabilities offered needed flexibility to users to customize the UI based on their needs."
      },
      {
        "type": "TextSection",
        "title": "Design Detail - Git Graph Tags",
        "text": "Complex UI like Git Repository window is full of design details that needed to be carefully considered and specified. This video illustrates how the Git history graph tags behave and scale when the table column width varies. This prototype was done in Figma and was naturally part of developer hand off."
      },
      {
        "type": "EmbeddedVideo",
        "url": "https://vimeo.com/1154602991?fl=pl&fe=sh",
        "caption": "Sizing rules for tags ensure that they remain legible and usable across different screen sizes and user preferences."
      },
      {
        "type": "TextSection",
        "title": "Impact",
        "text": "The updated UX was widely embraced and received strong positive feedback. From a forward-looking design perspective, the new architecture gave us reusable UI elements and a scalable structure that was easy to extend. This made it possible to start with a smaller MVP and gradually add new features in future releases.\n\n[The New Git Experience (YouTube)](https://www.youtube.com/watch?v=ZiQ2LXtAJ6I)"
      },
      {
        "type": "TextSection",
        "title": "Key Learnings",
        "text": "The new version control UI was by far the largest feature set I worked on during my time at Microsoft. It taught me a lot about designing for developer tools, and here are some of the key lessons I took away.\n\n **Seek diverse feedback**\n‚Ä¢ People‚Äôs brains are wired differently. Don‚Äôt assume that what makes sense to you will make sense to others. \n‚Ä¢ Share openly. Gathering feedback from users, peer designers, stakeholders, and developers (who are also users) is invaluable. \n\n**Know the product‚Äîand who you‚Äôre designing for**\n‚Ä¢ Sometimes prioritizing usability over minimalism or aesthetics is the right choice; other times, the opposite is true. For example: Developers are learned to love their hi-density UIs. \n‚Ä¢ Take advantage of the qualitative and quantitative data you have. \n\n**Be brave and critical**\n‚Ä¢ Design should have a point of view and clear reasoning behind it, even if loosely held. \n‚Ä¢ Removing features is a form of design‚Äîsometimes more important than adding new ones. \n‚Ä¢ Not all data or feedback is correct or reason to pivot. Often there is no single ‚Äúright‚Äù answer. \n\n**Good design needs to be implementable**\n‚Ä¢ Make your designs scalable and modular from the beginning. \n‚Ä¢ Consider business goals and time constraints.\n‚Ä¢ Take technical constraints into account early. \n\n**Communication is crucial**\n‚Ä¢ Learn different ways to communicate ideas and designs effectively, both asynchronously and in real time. \n‚Ä¢ Clear and precise communication helps avoid misunderstandings. \n\n**Take advantage of your design tool capabilities**\n‚Ä¢ Use design systems and keep them updated. If one doesn‚Äôt exist, create your own. \n‚Ä¢ Combine quick, rough prototypes with more precise ones for validation and engineering handoff. \n‚Ä¢ Invest time in making components scalable and reusable‚Äîit pays off later. \n ‚Ä¢ Keep design files organized and understandable for others (and your future self). \n ‚Ä¢ Maintain a single source of truth‚Äîthe design file."
      }
    ]
  },
  {
    "id": 7,
    "slug": "ubuntu-indicators",
    "title": "Ubuntu Touch Indicators", 
    "categories": ["Prototyping", "UX Design", "Tooling", "UI Development"],
    "description": "Gesture based indicator panel interactions for Ubuntu Touch OS.", 
    "thumbnail": "/project-5/thumb.webp",
    "show": true,
    "featured": false,
    "featured_image": "/project-5/featured.webp",
    "year": 2014,
    "role": "UX Prototyper",
    "client": "Canonical Ltd.",
    "content":[
      {
        "type": "TextSection",
        "title": "The UX Challenge",
        "text": "User testing had shown that the existing Ubuntu Touch indicators were suffering from several usability issues. My task was to redesign indicators and to fix the following problems:\n\n‚Ä¢  Users didn‚Äôt understand the connections between different UI elements.\n‚Ä¢ Users struggled with the swipe down gesture and didn‚Äôt get the targeted menu open.\n‚Ä¢ Users struggled navigating between open menus.\n‚Ä¢ The current design didn‚Äôt handle overflow situations when there are more indicators than available space."
      },
      {
        "type": "TextSection",
        "title": "The UX Approach",
        "text": "To handle the overflow **non-relevant indicators are hidden** in closed state. As soon as the opening gesture is started they become visible again and their menus are accessible. \n\nIndicator items expand once the gesture is started. Initial touch position provides **a horizontal anchor point** around which all expansions happen. This **ensures that the target item doesn‚Äôt move during the gesture**.\n\n**Vertical expansion** provides space for the label. Expanded item acts as a clear navigation element when indicators are open. Now two unconnected elements from the previous design were combined to one meaningful element.\n\n**Horizontal expansion provides space for more robust gesture** which was further enhanced with vertical velocity buffering and maximum vertical velocity threshold."
      },
      {
        "type": "ImageGallery",
        "images": [
          {
            "src": "/project-5/sketch.webp",
            "alt": "A paper and pen sketch of the final version before moving to digital design tools.",
            "caption": "A paper and pen sketch of the final version before moving to digital design tools."
          },
          {
            "src": "/project-5/variations.webp",
            "alt": "Collection of design mockups showing multiple layout and visual variations.",
            "caption": "Multiple layout and visual variations were explored to find the optimal solution."
          },
          {
            "src": "/project-5/spec.webp",
            "alt": "Design mockup 3 showing the new indicator interactions.",
            "caption": "Design documentation specifying the final design details for engineering handoff."
          }
        ]
      },
      {
        "type": "EmbeddedVideo",
        "url": "https://vimeo.com/1146523128?fl=tl&fe=ec",
        "caption": "Functional QML prototype (JSON-like syntax for UI structure with JavaScript for logic) demonstrating the new indicator interactions."
      },
      {
        "type": "TextSection",
        "title": "The UX Impact",
        "text": "The new design retained all the good functionality from the old indicators while fixing all usability issues. The new indicator design was user tested multiple times and the results have been significantly better. It fulfilled the stakeholder expectations and also got great feedback from the actual Ubuntu phone users."
      }
    ]
  },
  {
    "id": 5,
    "slug": "screenreader-plugin-for-figma",
    "title": "Figma Plugin - Screen Reader Tool",
    "categories": ["Tooling", "Accessibility", "UI Development"],
    "description": "Figma plugin to increase design workshop accessibility and productivity.", 
    "thumbnail": "/project-6/thumb.webp",
    "show": true,
    "featured": true,
    "featured_image": "/project-6/featured.webp",
    "year": 2023,
    "role": "Principal Designer",
    "client": "Microsoft Corporation",
    "content":[
      {
        "type": "TextSection",
        "title": "The Challenge",
        "text": "I attended a workshop focused on identifying problems with programming tools and improving the user experience from the perspective of screen reader users. I interviewed users and tried to communicate the tools I had created to them. I noticed the difficulty in communication because the designs were visual presentations, while visually impaired users rely on a screen reader as their sole interface daily. Validating the designs and obtaining concrete feedback was challenging."
      },
      {
        "type": "TextSection",
        "title": "The Solution",
        "text": "I wanted to design a better process and tool for accessible communication of designs to all workshop participants. I developed a plugin for the Figma design software I was using, which acted as a connecting tissue between the design tool and the operating system‚Äôs (macOS or Windows) screen reader (Narrator, VoiceOver, NVDA, JAWS, etc). The tool allowed designers to specify screen reader announcements (ARIA live regions) that were spoken aloud while the design was being interacted with."
      },
      {
        "type": "ImageGallery",
        "images": [
          {
            "src": "/project-6/instructions-create.webp",
            "alt": "Documentation screenshot showing how to create screen reader annotations in Figma.",
            "caption": "Create: Documentation on how to create screen reader annotations in Figma."
          },
          {
            "src": "/project-6/instructions-play.webp",
            "alt": "Documentation screenshot showing how to play screen reader annotations in Figma.",
            "caption": "Play: Documentation on how to play screen reader annotations in Figma."
          }
        ]
      },
      {
        "type": "TextSection",
        "title": "The Impact",
        "text": "The tool enabled more effective communication with visually impaired users, allowing us to receive concrete feedback on our solutions. This process strengthened empathy and collaboration with screen reader users and provided valuable insights into their specific needs. Personally, I gained extensive experience with screen readers, accessibility best practices, Copilot AI-assisted coding, Figma plugins, and the Vue front-end framework, which was new to me."
      }
    ]
  },
  {
    "id": 2,
    "slug": "pull-requests-in-visual-studio", 
    "title": "Pull Requests in Visual Studio - Design Process Showcase", 
    "categories": ["UX Design", "User Research"],
    "description": "I led the design of complex UI from the initial concepts to the final implementation to find the optimal solution for code review in Visual Studio IDE.", 
    "thumbnail": "/project-7/thumb-pr.webp",
    "show": true,
    "featured": true,
    "featured_image": "/project-7/thumb-pr.webp",
    "year": 2024,
    "role": "Principal Designer",
    "client": "Microsoft Corporation",
    "content":[
      {
        "type": "ImageSection",
        "title": "The Objective",
        "image": "/project-7/about.webp",
        "alt": "An image representing pull request flow in general.",
        "caption": "I created this image to help communicate the concept of pull requests to stakeholders and users unfamiliar with the term.",
        "align": "below",
        "text": "A pull request (PR) is a collaborative tool used in version control systems like Git to propose and discuss changes to a codebase. Developers create pull requests to request that their changes be reviewed and merged into the main codebase by other team members. \n\nVisual Studio developer environment lacked all pull request capabilities and the feature was one of the highest request items among the community. \n\nMy task was to design a seamless pull request experience within Visual Studio IDE, enabling developers to efficiently review, comment on, fix comments, and merge code changes without leaving their development environment."
      },
      {
        "type": "TextSection",
        "title": "User Research",
        "text": "I started with a competitive analysis and benchmarking the core user flows in existing experiences. At the same time I collected customer and problem hypotheses to be validated. I created some lo-fidelity wireframes to support design communications, user research and spark the discussion with our customers."
      },
      {
        "type": "ImageGallery",
        "images": [
          {
            "src": "/project-7/wireframes.webp",
            "alt": "Low-fidelity wireframes used in initial concepting and user research.",
            "caption": "Low-fidelity wireframes used in initial concepting and user research."
          },
          {
            "src": "/project-7/hypos.webp",
            "alt": "A set of customer and problem hypotheses to validate with users.",
            "caption": "Based on my research and understanding of the problem space, I created a set of hypotheses to validate with users."
          }
        ]
      },
      {
        "type": "TextSection",
        "title": "",
        "text": "My partner programs (kudos to Jessie Houghton and Taysser Gherfal) interviewed developers from various backgrounds and experience levels to understand their pain points, needs, and preferences when it comes to code review and collaboration. We then together synthesized the findings and identified key themes and insights."
      },
      {
        "type": "ImageSection",
        "title": "Research Findings",
        "image": "/project-7/roles.webp",
        "alt": "An image of research finding: Two main roles and their jobs in pull request flow.",
        "caption": "Two main roles and their jobs in pull request flow.",
        "align": "below",
        "text": "Developers expressed a desire for a streamlined workflow that minimizes context switching and enhances productivity during code reviews. It became clear how the user role (author vs reviewer) defines which pull request features are the most relevant in the coding environment. \n\n Some user comments: \n\n_\"I want to create my pull requests in the IDE right after finishing my code‚Äù_\n\n_\"I want to take full advantage of the Visual Studio while reviewing or fixing issues in the PR‚Äù_ \n\n_‚ÄúAs an author I want to use the IDE to fix the PR comments.‚Äù_\n\n_‚ÄúI want to have the PR open on a separate monitor while working on PR changes‚Äù_\"‚Äù_\n\n_\"Notifications during coding mostly just annoy me and break my flow‚Äù_"
      },
      {
        "type": "TextSection",
        "title": "Key UX Challenges",
        "text": "User testing helped answer foundational questions and clarify where to start and which features to prioritize. However, the majority of the UI design work still lay ahead, raising several key UX challenges: \n\n **Scope of pull request functionality:** \n Which pull request capabilities are essential, which can be deferred, and what criteria guide those decisions? \n\n**MVP vs. North Star vision:** \nWhat does the MVP design look like compared to the North Star experience, and how can the product evolve smoothly from one to the other?\n\n **Ecosystem consistency:** \nHow can the design align with existing GitHub and Azure DevOps pull request experiences‚Äîacross iconography, terminology, and UI patterns‚Äîwhile still feeling native?\n\n **Cross-product coherence:** \n What does a coherent design look like across two different products‚ÄîVisual Studio (Windows) and Visual Studio Code‚Äîand where should the experiences intentionally diverge? \n\n **Layout and screen real estate:** \n Which layout options best support core user flows, maximize screen space for efficient code review, and integrate cleanly with the existing version control UI?"
      },
      {
        "type": "ImageSection",
        "title": "Design Iterations",
        "image": "/project-7/polished-concept.webp",
        "alt": "A polished design concept with pull request experience in Visual Studio.",
        "caption": "I started narrowing down the design options into 2-3 polished concepts.",
        "align": "below",
        "text": "I created multiple design iterations to explore different approaches. Each iteration focused on addressing specific pain points identified during user research and concept development. I gathered feedback from internal and external users and stakeholders to refine the designs and  ensure they met the needs of developers. I also validated the designs with the engineering team for further ideation, transparency, buy in, and to ensure implementation feasibility."
      },
      {
        "type": "TextSection",
        "text": "There were many design details that needed to be figured out along the way:"
      },
      {
        "type": "ImageGallery",
        "images": [
          {
            "src": "/project-7/toasts.webp",
            "alt": "Toast notifications providing contextual information during coding flow.",
            "caption": "Toast notifications could to provide status information and contextual quick actions."
          },
          {
            "src": "/project-7/status-section.webp",
            "alt": "Top section of the details panel showing overall PR status and key information.",
            "caption": "Top section of the details panel could provide overall PR status and key information that is easily accessible."
          },
          {
            "src": "/project-7/tabbed-nav.webp",
            "alt": "Tabbed navigation to switch between different PR views.",
            "caption": "Tabbed navigation to switch between different PR views was considered."
          },
          {
            "src": "/project-7/info-notifications.webp",
            "alt": "Infobar notifications providing non-intrusive information and quick actions.",
            "caption": "Infobar notifications to provide non-intrusive information and quick actions."
          },
          {
            "src": "/project-7/creation-finished.webp",
            "alt": "Pull request creation finished state.",
            "caption": "Pull request creation finished state."
          },
          {
            "src": "/project-7/preview.webp",
            "alt": "Ability to maximize the pull request details panel and Markdown preview are important when writing more complex descriptions.",
            "caption": "Ability to maximize the pull request details panel and Markdown preview are important when writing more complex descriptions."
          }
        ]
      },
      {
        "type": "ImageSection",
        "title": "Final Design",
        "image": "/project-7/final-create.webp",
        "alt": "The design mocup showing the final pull request experience in Visual Studio.",
        "caption": "Create pull request layout UI for contextual pull request creation.",
        "align": "below",
        "text": "The final Northstar design focused especially on improving the pull request authors efficiency and powering them with tools that reduce context switching and make flows as seamless as possible. Here some high-level screenshots from the final design documentation giving and idea of top-level architecture:"
      },
      {
        "type": "ImageSection",
        "title": "",
        "image": "/project-7/final-contained.webp",
        "alt": "The design mocup showing the final pull request experience in Visual Studio.",
        "caption": "Contained layout for code review and quick pull request scans.",
        "align": "below",
        "text": ""
      },
      {
        "type": "ImageSection",
        "title": "",
        "image": "/project-7/final-full.webp",
        "alt": "The design mocup showing the final pull request experience in Visual Studio.",
        "caption": "Full screen layout for efficient code fixes and full language server support.",
        "align": "below",
        "text": ""
      },
      {
        "type": "TextSection",
        "text": "The feature set was designed with scalability in mind, enabling a phased rollout from MVP to a more advanced experience without rework. Early releases focused on core pull request author workflows, while subsequent iterations introduced advanced features informed by user feedback and prioritization."
      }
    ]
  }
]
